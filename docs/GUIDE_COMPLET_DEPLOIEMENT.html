<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guide Complet - D√©ploiement MedFlow sur Kubernetes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 40px;
        }
        
        h1 {
            color: #667eea;
            border-bottom: 4px solid #764ba2;
            padding-bottom: 10px;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        h2 {
            color: #764ba2;
            margin-top: 40px;
            margin-bottom: 20px;
            padding: 10px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            color: white;
            border-radius: 5px;
            font-size: 1.8em;
        }
        
        h3 {
            color: #667eea;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.4em;
            border-left: 4px solid #764ba2;
            padding-left: 10px;
        }
        
        h4 {
            color: #555;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        .section {
            margin-bottom: 40px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 5px solid #667eea;
        }
        
        .command-box {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow-x: auto;
            border-left: 4px solid #4ec9b0;
        }
        
        .command-box code {
            color: #4ec9b0;
            font-size: 0.95em;
        }
        
        .explanation {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
        }
        
        .warning {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }
        
        .success {
            background: #d4edda;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #28a745;
        }
        
        .info-box {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-top: 10px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .code-block {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow-x: auto;
            border: 1px solid #ddd;
            white-space: pre-wrap;
            white-space: -moz-pre-wrap;
            white-space: -pre-wrap;
            white-space: -o-pre-wrap;
            word-wrap: break-word;
        }
        
        .code-block pre {
            margin: 0;
            padding: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            white-space: pre;
            overflow-x: auto;
        }
        
        .toc {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .toc ul {
            list-style: none;
            margin-left: 0;
        }
        
        .toc a {
            color: #667eea;
            text-decoration: none;
            font-weight: bold;
        }
        
        .toc a:hover {
            text-decoration: underline;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        table th, table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        table th {
            background: #667eea;
            color: white;
        }
        
        table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.85em;
            font-weight: bold;
            margin: 0 5px;
        }
        
        .badge-success {
            background: #28a745;
            color: white;
        }
        
        .badge-warning {
            background: #ffc107;
            color: #333;
        }
        
        .badge-info {
            background: #17a2b8;
            color: white;
        }
        
        .step-number {
            display: inline-block;
            width: 30px;
            height: 30px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .architecture-diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Guide Complet - D√©ploiement MedFlow sur Kubernetes</h1>
        
        <div class="toc">
            <h3>üìë Table des Mati√®res</h3>
            <ul>
                <li><a href="#introduction">1. Introduction</a></li>
                <li><a href="#yaml-files">2. Tous les Manifests YAML</a></li>
                <li><a href="#prerequis">3. Pr√©requis</a></li>
                <li><a href="#etape1">4. √âtape 1 : D√©marrage de Minikube</a></li>
                <li><a href="#etape2">5. √âtape 2 : Configuration Backend (Health Check)</a></li>
                <li><a href="#etape3">6. √âtape 3 : Dockerfiles et Images</a></li>
                <li><a href="#etape4">7. √âtape 4 : Configuration Kubernetes (ConfigMap & Secrets)</a></li>
                <li><a href="#etape5">8. √âtape 5 : Deployments et Services</a></li>
                <li><a href="#etape6">9. √âtape 6 : MongoDB</a></li>
                <li><a href="#etape7">10. √âtape 7 : Ingress et Acc√®s Externe</a></li>
                <li><a href="#etape8">11. √âtape 8 : HPA (Auto-scaling)</a></li>
                <li><a href="#etape9">12. √âtape 9 : Monitoring (Prometheus/Grafana)</a></li>
                <li><a href="#etape10">13. √âtape 10 : CI/CD Pipeline</a></li>
                <li><a href="#commandes">14. Commandes de V√©rification</a></li>
                <li><a href="#mongoexpress">15. MongoDB Express</a></li>
                <li><a href="#superadmin">16. Cr√©ation du SuperAdmin</a></li>
                <li><a href="#gestion-images">17. Gestion des Images Docker</a></li>
                <li><a href="#reconstruction">18. Reconstruction des Images</a></li>
                <li><a href="#troubleshooting">19. D√©pannage</a></li>
                <li><a href="#glossaire">20. Glossaire - D√©finitions</a></li>
            </ul>
        </div>

        <!-- INTRODUCTION -->
        <div id="introduction" class="section">
            <h2>1. Introduction</h2>
            <p>Ce guide documente le d√©ploiement complet de l'application MedFlow sur Kubernetes avec Minikube, incluant le monitoring, l'auto-scaling et le CI/CD.</p>
            
            <h3>Architecture du Syst√®me</h3>
            <div class="architecture-diagram">
Namespace: medflow
‚îú‚îÄ‚îÄ Backend
‚îÇ   ‚îú‚îÄ‚îÄ Deployment (3 pods)
‚îÇ   ‚îú‚îÄ‚îÄ Service (ClusterIP:80 ‚Üí pods:4000)
‚îÇ   ‚îî‚îÄ‚îÄ HPA (2-10 pods)
‚îú‚îÄ‚îÄ Dashboard
‚îÇ   ‚îú‚îÄ‚îÄ Deployment (2 pods)
‚îÇ   ‚îú‚îÄ‚îÄ Service (ClusterIP:80 ‚Üí pods:80)
‚îÇ   ‚îî‚îÄ‚îÄ HPA (2-8 pods)
‚îú‚îÄ‚îÄ Frontend
‚îÇ   ‚îú‚îÄ‚îÄ Deployment (2 pods)
‚îÇ   ‚îú‚îÄ‚îÄ Service (ClusterIP:80 ‚Üí pods:80)
‚îÇ   ‚îî‚îÄ‚îÄ HPA (2-8 pods)
‚îî‚îÄ‚îÄ MongoDB
    ‚îú‚îÄ‚îÄ StatefulSet (1 pod)
    ‚îî‚îÄ‚îÄ Service (Headless:27017)

Namespace: monitoring
‚îú‚îÄ‚îÄ Prometheus
‚îÇ   ‚îú‚îÄ‚îÄ Deployment (1 pod)
‚îÇ   ‚îî‚îÄ‚îÄ Service (ClusterIP:9090)
‚îî‚îÄ‚îÄ Grafana
    ‚îú‚îÄ‚îÄ Deployment (1 pod)
    ‚îî‚îÄ‚îÄ Service (ClusterIP:80)
            </div>
        </div>

        <!-- YAML FILES -->
        <div id="yaml-files" class="section">
            <h2>2. Tous les Manifests YAML - R√©f√©rence Compl√®te</h2>
            
            <div class="info-box">
                <strong>üìã Organisation :</strong> Tous les fichiers YAML sont organis√©s par cat√©gorie. Cliquez sur chaque section pour voir le contenu complet.
            </div>

            <!-- CONFIGMAP & SECRETS -->
            <h3>üì¶ Configuration et Secrets</h3>
            
            <h4>ConfigMap - k8s/configmap.yaml</h4>
            <div class="code-block"><pre>apiVersion: v1
kind: ConfigMap
metadata:
  name: medflow-config
  namespace: medflow
data:
  PORT: "4000"
  NODE_ENV: "production"
  FRONTEND_URL: "http://localhost:5173,https://mern-hospital-managment.vercel.app"
  DASHBOARD_URL: "http://localhost:5174,https://mern-hospital-managment-2q8w.vercel.app"
  JWT_EXPIRES: "7d"
  COOKIE_EXPIRE: "7"</pre></div>

            <h4>Secret - k8s/secret.yaml</h4>
            <div class="code-block"><pre>apiVersion: v1
kind: Secret
metadata:
  name: medflow-secrets
  namespace: medflow
type: Opaque
data:
  # JWT Secret Key (base64 encoded)
  jwt-secret-key: ZGZlcmV0YnZkZmJydHloeXludWlrZA==
  
  # MongoDB URI (base64 encoded) - MongoDB local Kubernetes
  mongo-uri: bW9uZ29kYjovL2FkbWluOk1lZEZsb3cyMDI0U2VjdXJlIUBtb25nb2RiLXNlcnZpY2U6MjcwMTcvTWVGbG93Mj9hdXRoU291cmNlPWFkbWlu
  
  # MongoDB Password pour StatefulSet local (base64 encoded)
  mongo-password: TWVkRmxvdzIwMjRTZWN1cmUh
  
  # Cloudinary Configuration (base64 encoded)
  cloudinary-cloud-name: ZGFxdm5mc285
  cloudinary-api-key: MjkzNDg4MjQzNTg2NDU3
  cloudinary-api-secret: ZUgyb2ZmRnBGaTJwa2hCRG1HRWJReGVWcnhZ</pre></div>

            <!-- BACKEND -->
            <h3>üîß Backend</h3>
            
            <h4>Backend Deployment - k8s/backend-deployment.yaml</h4>
            <div class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
  namespace: medflow
  labels:
    app: backend
spec:
  replicas: 3  # Nombre de pods (copies) √† cr√©er
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
        version: v1
    spec:
      containers:
      - name: backend
        image: medflow-backend:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 4000
          name: http
          protocol: TCP
        
        # Variables d'environnement depuis ConfigMap
        envFrom:
        - configMapRef:
            name: medflow-config
        
        # Variables d'environnement depuis Secret
        env:
        - name: JWT_SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: jwt-secret-key
        - name: MONGO_URI
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: mongo-uri
        - name: CLOUDINARY_CLOUD_NAME
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: cloudinary-cloud-name
        - name: CLOUDINARY_API_KEY
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: cloudinary-api-key
        - name: CLOUDINARY_API_SECRET
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: cloudinary-api-secret
        
        # Ressources (CPU et RAM)
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        
        # Health Checks
        livenessProbe:
          httpGet:
            path: /api/v1/health
            port: 4000
          initialDelaySeconds: 40
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /api/v1/health
            port: 4000
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
  
  # Strat√©gie de mise √† jour
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
            </div>

            <h4>Backend Service - k8s/backend-service.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: medflow
  labels:
    app: backend
spec:
  type: ClusterIP  # Service accessible uniquement dans le cluster
  selector:
    app: backend
  ports:
  - port: 80
    targetPort: 4000
    protocol: TCP
    name: http
            </div>

            <!-- FRONTEND -->
            <h3>üé® Frontend</h3>
            
            <h4>Frontend Deployment - k8s/frontend-deployment.yaml</h4>
            <div class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
  namespace: medflow
  labels:
    app: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
        version: v1
    spec:
      containers:
      - name: frontend
        image: medflow-frontend:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
          name: http
          protocol: TCP
        
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
  
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
            </div>

            <h4>Frontend Service - k8s/frontend-service.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: medflow
  labels:
    app: frontend
spec:
  type: ClusterIP
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
            </div>

            <!-- DASHBOARD -->
            <h3>üìä Dashboard</h3>
            
            <h4>Dashboard Deployment - k8s/dashboard-deployment.yaml</h4>
            <div class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dashboard-deployment
  namespace: medflow
  labels:
    app: dashboard
spec:
  replicas: 2
  selector:
    matchLabels:
      app: dashboard
  template:
    metadata:
      labels:
        app: dashboard
        version: v1
    spec:
      containers:
      - name: dashboard
        image: medflow-dashboard:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
          name: http
          protocol: TCP
        
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
  
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
            </div>

            <h4>Dashboard Service - k8s/dashboard-service.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: dashboard-service
  namespace: medflow
  labels:
    app: dashboard
spec:
  type: ClusterIP
  selector:
    app: dashboard
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
            </div>

            <!-- MONGODB -->
            <h3>üóÑÔ∏è MongoDB</h3>
            
            <h4>MongoDB StatefulSet - k8s/mongodb-statefulset.yaml</h4>
            <div class="code-block">
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongodb
  namespace: medflow
spec:
  serviceName: mongodb-service
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:7.0
        ports:
        - containerPort: 27017
          name: mongodb
          protocol: TCP
        
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          value: "admin"
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: mongo-password
        - name: MONGO_INITDB_DATABASE
          value: "MeFlow2"
        
        volumeMounts:
        - name: mongodb-storage
          mountPath: /data/db
        
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        
        livenessProbe:
          exec:
            command:
            - mongosh
            - --eval
            - "db.adminCommand('ping')"
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        
        readinessProbe:
          exec:
            command:
            - mongosh
            - --eval
            - "db.adminCommand('ping')"
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
  
  volumeClaimTemplates:
  - metadata:
      name: mongodb-storage
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: standard
      resources:
        requests:
          storage: 10Gi
            </div>

            <h4>MongoDB Service - k8s/mongodb-service.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service
  namespace: medflow
spec:
  clusterIP: None  # Service headless
  selector:
    app: mongodb
  ports:
  - port: 27017
    targetPort: 27017
    protocol: TCP
    name: mongodb
            </div>

            <h4>MongoDB PVC - k8s/mongodb-pvc.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pvc
  namespace: medflow
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: standard
            </div>

            <!-- INGRESS -->
            <h3>üåê Ingress</h3>
            
            <h4>Ingress - k8s/ingress.yaml</h4>
            <div class="code-block">
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: medflow-ingress
  namespace: medflow
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  # Route pour l'API Backend
  - host: api.medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: backend-service
            port:
              number: 80
  
  # Route pour le Dashboard
  - host: dashboard.medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: dashboard-service
            port:
              number: 80
  
  # Route pour le Frontend Patient
  - host: medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
  
  # Route pour MongoDB Express
  - host: mongo.medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: mongo-express-service
            port:
              number: 80
            </div>

            <!-- HPA -->
            <h3>üìà Auto-scaling (HPA)</h3>
            
            <h4>Backend HPA - k8s/backend-hpa.yaml</h4>
            <div class="code-block">
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-hpa
  namespace: medflow
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend-deployment
  
  minReplicas: 2
  maxReplicas: 10
  
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      - type: Pods
        value: 1
        periodSeconds: 60
      selectPolicy: Min
    
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 2
        periodSeconds: 15
      selectPolicy: Max
            </div>

            <h4>Frontend HPA - k8s/frontend-hpa.yaml</h4>
            <div class="code-block">
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: frontend-hpa
  namespace: medflow
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: frontend-deployment
  
  minReplicas: 2
  maxReplicas: 8
  
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      selectPolicy: Min
    
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      selectPolicy: Max
            </div>

            <!-- MONGO EXPRESS -->
            <h3>üîç MongoDB Express</h3>
            
            <h4>Mongo Express Deployment - k8s/mongo-express-deployment.yaml</h4>
            <div class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongo-express
  namespace: medflow
  labels:
    app: mongo-express
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongo-express
  template:
    metadata:
      labels:
        app: mongo-express
    spec:
      containers:
      - name: mongo-express
        image: mongo-express:latest
        ports:
        - containerPort: 8081
          name: http
        env:
        - name: ME_CONFIG_MONGODB_ADMINUSERNAME
          value: "admin"
        - name: ME_CONFIG_MONGODB_ADMINPASSWORD
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: mongo-password
        - name: ME_CONFIG_MONGODB_URL
          value: "mongodb://admin:MedFlow2024Secure!@mongodb-service:27017/"
        - name: ME_CONFIG_MONGODB_SERVER
          value: "mongodb-service"
        - name: ME_CONFIG_MONGODB_PORT
          value: "27017"
        - name: ME_CONFIG_BASICAUTH_USERNAME
          value: "admin"
        - name: ME_CONFIG_BASICAUTH_PASSWORD
          value: "admin123"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 8081
          initialDelaySeconds: 10
          periodSeconds: 5
            </div>

            <h4>Mongo Express Service - k8s/mongo-express-service.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: mongo-express-service
  namespace: medflow
  labels:
    app: mongo-express
spec:
  type: ClusterIP
  selector:
    app: mongo-express
  ports:
  - port: 80
    targetPort: 8081
    protocol: TCP
    name: http
            </div>

            <!-- PROMETHEUS -->
            <h3>üìä Prometheus (Monitoring)</h3>
            
            <h4>Prometheus ConfigMap - k8s/monitoring/prometheus-configmap.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: monitoring
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
      evaluation_interval: 15s
      external_labels:
        cluster: 'medflow-local'
        environment: 'development'

    scrape_configs:
      # M√©triques Kubernetes
      - job_name: 'kubernetes-apiservers'
        kubernetes_sd_configs:
        - role: endpoints
        scheme: https
        tls_config:
          insecure_skip_verify: true

      # M√©triques des pods Kubernetes
      - job_name: 'kubernetes-pods'
        kubernetes_sd_configs:
        - role: pod
        relabel_configs:
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
          action: keep
          regex: true

      # M√©triques de l'application MedFlow (Backend)
      - job_name: 'medflow-backend'
        kubernetes_sd_configs:
        - role: pod
          namespaces:
            names:
            - medflow
        relabel_configs:
        - source_labels: [__meta_kubernetes_pod_label_app]
          action: keep
          regex: backend
        - source_labels: [__meta_kubernetes_pod_ip]
          action: replace
          target_label: __address__
          replacement: $1:4000
        metrics_path: /api/v1/metrics
            </div>

            <h4>Prometheus Deployment - k8s/monitoring/prometheus-deployment.yaml</h4>
            <div class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: monitoring
  labels:
    app: prometheus
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      serviceAccountName: prometheus
      containers:
      - name: prometheus
        image: prom/prometheus:latest
        args:
          - '--config.file=/etc/prometheus/prometheus.yml'
          - '--storage.tsdb.path=/prometheus'
          - '--storage.tsdb.retention.time=15d'
          - '--web.enable-lifecycle'
        ports:
        - containerPort: 9090
          name: http
        volumeMounts:
        - name: prometheus-config
          mountPath: /etc/prometheus
        - name: prometheus-storage
          mountPath: /prometheus
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /-/healthy
            port: 9090
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /-/ready
            port: 9090
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: prometheus-config
        configMap:
          name: prometheus-config
      - name: prometheus-storage
        emptyDir: {}
            </div>

            <h4>Prometheus Service - k8s/monitoring/prometheus-service.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: prometheus-service
  namespace: monitoring
  labels:
    app: prometheus
spec:
  type: ClusterIP
  selector:
    app: prometheus
  ports:
  - port: 9090
    targetPort: 9090
    protocol: TCP
    name: http
            </div>

            <h4>Prometheus RBAC - k8s/monitoring/prometheus-rbac.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
  namespace: monitoring
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus
rules:
- apiGroups: [""]
  resources:
  - nodes
  - nodes/proxy
  - services
  - endpoints
  - pods
  verbs: ["get", "list", "watch"]
- apiGroups:
  - extensions
  resources:
  - ingresses
  verbs: ["get", "list", "watch"]
- nonResourceURLs: ["/metrics"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: monitoring
            </div>

            <h4>Prometheus Ingress - k8s/monitoring/prometheus-ingress.yaml</h4>
            <div class="code-block">
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: prometheus-ingress
  namespace: monitoring
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  - host: prometheus.medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: prometheus-service
            port:
              number: 9090
            </div>

            <!-- GRAFANA -->
            <h3>üìà Grafana (Visualisation)</h3>
            
            <h4>Grafana ConfigMap - k8s/monitoring/grafana-configmap.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-datasources
  namespace: monitoring
data:
  prometheus.yaml: |
    apiVersion: 1
    datasources:
    - name: Prometheus
      type: prometheus
      access: proxy
      url: http://prometheus-service.monitoring.svc.cluster.local:9090
      isDefault: true
      editable: true
            </div>

            <h4>Grafana Deployment - k8s/monitoring/grafana-deployment.yaml</h4>
            <div class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  namespace: monitoring
  labels:
    app: grafana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
      - name: grafana
        image: grafana/grafana:latest
        ports:
        - containerPort: 3000
          name: http
        env:
        - name: GF_SECURITY_ADMIN_USER
          value: "admin"
        - name: GF_SECURITY_ADMIN_PASSWORD
          value: "admin123"
        - name: GF_SERVER_ROOT_URL
          value: "http://grafana.medflow.local"
        - name: GF_INSTALL_PLUGINS
          value: "grafana-piechart-panel"
        volumeMounts:
        - name: grafana-storage
          mountPath: /var/lib/grafana
        - name: grafana-datasources
          mountPath: /etc/grafana/provisioning/datasources
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: grafana-storage
        emptyDir: {}
      - name: grafana-datasources
        configMap:
          name: grafana-datasources
            </div>

            <h4>Grafana Service - k8s/monitoring/grafana-service.yaml</h4>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: grafana-service
  namespace: monitoring
  labels:
    app: grafana
spec:
  type: ClusterIP
  selector:
    app: grafana
  ports:
  - port: 80
    targetPort: 3000
    protocol: TCP
    name: http
            </div>

            <h4>Grafana Ingress - k8s/monitoring/grafana-ingress.yaml</h4>
            <div class="code-block">
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: grafana-ingress
  namespace: monitoring
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  - host: grafana.medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: grafana-service
            port:
              number: 80
            </div>

            <div class="success">
                <strong>‚úÖ R√©sum√© :</strong> 25 fichiers YAML au total organis√©s par cat√©gorie :
                <ul>
                    <li>2 fichiers de configuration (ConfigMap, Secret)</li>
                    <li>6 Deployments (Backend, Frontend, Dashboard, MongoDB, Mongo Express, Prometheus, Grafana)</li>
                    <li>7 Services (Backend, Frontend, Dashboard, MongoDB, Mongo Express, Prometheus, Grafana)</li>
                    <li>1 StatefulSet (MongoDB)</li>
                    <li>1 PVC (MongoDB)</li>
                    <li>3 Ingress (MedFlow, Prometheus, Grafana)</li>
                    <li>2 HPA (Backend, Frontend)</li>
                    <li>3 ConfigMaps (MedFlow, Prometheus, Grafana)</li>
                    <li>1 RBAC (Prometheus)</li>
                </ul>
            </div>
        </div>

        <!-- PREREQUIS -->
        <div id="prerequis" class="section">
            <h2>3. Pr√©requis</h2>
            <ul>
                <li>‚úÖ Docker Desktop install√© et d√©marr√©</li>
                <li>‚úÖ Minikube install√©</li>
                <li>‚úÖ kubectl install√© et configur√©</li>
                <li>‚úÖ Node.js 18+ install√©</li>
                <li>‚úÖ PowerShell (Windows) ou Terminal (Linux/Mac)</li>
            </ul>
            
            <div class="warning" style="margin-top: 20px;">
                <strong>‚ö†Ô∏è Important - Docker Desktop :</strong>
                <p><strong>Oui, Docker Desktop DOIT √™tre d√©marr√©</strong> pour que tout fonctionne (Frontend, Backend, Dashboard).</p>
                <p><strong>Pourquoi ?</strong></p>
                <ul>
                    <li>Minikube utilise Docker Desktop comme driver (<code>--driver=docker</code>)</li>
                    <li>Minikube cr√©e un conteneur Docker qui h√©berge le cluster Kubernetes</li>
                    <li>Les images Docker sont construites et stock√©es dans Docker Desktop</li>
                    <li>Les Pods Kubernetes s'ex√©cutent dans des conteneurs Docker</li>
                </ul>
                <p><strong>Ordre de d√©marrage :</strong></p>
                <ol>
                    <li>1Ô∏è‚É£ D√©marrer Docker Desktop (attendre qu'il soit compl√®tement d√©marr√©)</li>
                    <li>2Ô∏è‚É£ D√©marrer Minikube : <code>minikube start --driver=docker</code></li>
                    <li>3Ô∏è‚É£ V√©rifier : <code>kubectl get pods -n medflow</code></li>
                </ol>
                <p><strong>V√©rifier que Docker Desktop fonctionne :</strong></p>
                <div class="command-box">
                    <code>docker ps</code>
                </div>
                <p>Si cette commande fonctionne, Docker Desktop est op√©rationnel.</p>
            </div>
            
            <div class="info-box" style="margin-top: 20px;">
                <strong>üí° Alternative :</strong> Si vous ne voulez pas utiliser Docker Desktop, vous pouvez utiliser Minikube avec d'autres drivers :
                <ul>
                    <li><code>minikube start --driver=virtualbox</code> (n√©cessite VirtualBox)</li>
                    <li><code>minikube start --driver=hyperv</code> (Windows avec Hyper-V)</li>
                    <li><code>minikube start --driver=vmware</code> (n√©cessite VMware)</li>
                </ul>
                <p><strong>Note :</strong> Dans ce guide, nous utilisons Docker Desktop car c'est le plus simple et le plus courant.</p>
            </div>
        </div>

        <!-- ETAPE 1 -->
        <div id="etape1" class="section">
            <h2><span class="step-number">4</span>D√©marrage de Minikube</h2>
            
            <h3>1.1 D√©marrer Minikube</h3>
            <div class="command-box">
                <code>minikube start --driver=docker</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> D√©marre Minikube avec le driver Docker. Minikube cr√©e une VM ou un conteneur Docker pour h√©berger le cluster Kubernetes.
            </div>

            <h3>1.2 V√©rifier le Cluster</h3>
            <div class="command-box">
                <code>kubectl get nodes</code>
            </div>
            <div class="command-box">
                <code>kubectl cluster-info</code>
            </div>
            <div class="success">
                <strong>R√©sultat attendu :</strong> Un n≈ìud "minikube" en statut "Ready"
            </div>

            <h3>1.3 Cr√©er le Namespace</h3>
            <div class="command-box">
                <code>kubectl create namespace medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl get namespaces</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Le namespace "medflow" isole toutes les ressources de l'application (pods, services, deployments, etc.) des autres applications dans le cluster.
            </div>
        </div>

        <!-- ETAPE 2 -->
        <div id="etape2" class="section">
            <h2><span class="step-number">5</span>Configuration Backend - Health Check</h2>
            
            <h3>2.1 Ajouter l'Endpoint Health Check</h3>
            <p>Dans <code>backend/app.js</code>, ajoutez :</p>
            <div class="code-block">
// Health check endpoint for Kubernetes
app.get("/api/v1/health", (req, res) => {
    res.status(200).json({ 
        status: "healthy", 
        timestamp: new Date().toISOString(),
        service: "medflow-backend"
    });
});
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Kubernetes utilise cet endpoint pour v√©rifier que le pod est en bonne sant√© (livenessProbe et readinessProbe).
            </div>

            <h3>2.2 Ajouter l'Endpoint M√©triques (pour Prometheus)</h3>
            <p>Dans <code>backend/app.js</code>, ajoutez :</p>
            <div class="code-block">
// Metrics endpoint for Prometheus
app.get("/api/v1/metrics", (req, res) => {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();
    const uptime = process.uptime();
    
    const metrics = [
        `# HELP nodejs_heap_size_total_bytes Process heap size from Node.js`,
        `# TYPE nodejs_heap_size_total_bytes gauge`,
        `nodejs_heap_size_total_bytes ${memUsage.heapTotal}`,
        ``,
        `# HELP nodejs_heap_size_used_bytes Process heap size used from Node.js`,
        `# TYPE nodejs_heap_size_used_bytes gauge`,
        `nodejs_heap_size_used_bytes ${memUsage.heapUsed}`,
        ``,
        `# HELP medflow_uptime_seconds Uptime in seconds`,
        `# TYPE medflow_uptime_seconds gauge`,
        `medflow_uptime_seconds ${uptime}`,
    ].join('\n');
    
    res.set('Content-Type', 'text/plain; version=0.0.4');
    res.send(metrics);
});
            </div>
        </div>

        <!-- ETAPE 3 -->
        <div id="etape3" class="section">
            <h2><span class="step-number">6</span>Dockerfiles et Images Docker</h2>
            
            <h3>3.1 Structure des Dockerfiles</h3>
            <p>Chaque composant a son propre Dockerfile :</p>
            <ul>
                <li><code>backend/Dockerfile</code> - Image Node.js pour le backend</li>
                <li><code>frontend/Dockerfile</code> - Build React + Nginx</li>
                <li><code>dashboard/Dockerfile</code> - Build React + Nginx</li>
            </ul>

            <h3>3.2 Cr√©er nginx.conf pour Dashboard et Frontend</h3>
            <p>Cr√©ez <code>dashboard/nginx.conf</code> et <code>frontend/nginx.conf</code> :</p>
            <div class="code-block">
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
            </div>

            <h3>3.3 Construire les Images Docker</h3>
            <div class="command-box">
                <code>docker build -t medflow-backend:latest ./backend</code>
            </div>
            <div class="command-box">
                <code>docker build --build-arg VITE_API_BASE_URL=http://api.medflow.local/api/v1 -t medflow-frontend:latest ./frontend</code>
            </div>
            <div class="command-box">
                <code>docker build --build-arg VITE_API_BASE_URL=http://api.medflow.local/api/v1 -t medflow-dashboard:latest ./dashboard</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Les images sont construites localement. Pour Minikube, il faut les charger dans le contexte Docker de Minikube.
            </div>

            <h3>3.4 Charger les Images dans Minikube</h3>
            <div class="warning">
                <strong>‚ö†Ô∏è Important :</strong> Utilisez <code>minikube image build</code> pour construire directement dans Minikube, ou <code>minikube image load</code> apr√®s construction.
            </div>
            <div class="command-box">
                <code>minikube image build -t medflow-backend:latest ./backend</code>
            </div>
            <div class="command-box">
                <code>minikube image build --build-arg VITE_API_BASE_URL=http://api.medflow.local/api/v1 -t medflow-frontend:latest ./frontend</code>
            </div>
            <div class="command-box">
                <code>minikube image build --build-arg VITE_API_BASE_URL=http://api.medflow.local/api/v1 -t medflow-dashboard:latest ./dashboard</code>
            </div>

            <h3>3.5 V√©rifier les Images dans Minikube</h3>
            <div class="command-box">
                <code>minikube ssh -- docker images | findstr medflow</code>
            </div>
            <div class="success">
                <strong>R√©sultat attendu :</strong> Les 3 images medflow-backend, medflow-frontend, medflow-dashboard
            </div>
        </div>

        <!-- ETAPE 4 -->
        <div id="etape4" class="section">
            <h2><span class="step-number">7</span>Configuration Kubernetes - ConfigMap & Secrets</h2>
            
            <h3>4.1 Cr√©er le ConfigMap</h3>
            <p>Cr√©ez <code>k8s/configmap.yaml</code> :</p>
            <div class="code-block">
apiVersion: v1
kind: ConfigMap
metadata:
  name: medflow-config
  namespace: medflow
data:
  PORT: "4000"
  NODE_ENV: "production"
  FRONTEND_URL: "http://localhost:5173,https://mern-hospital-managment.vercel.app"
  DASHBOARD_URL: "http://localhost:5174,https://mern-hospital-managment-2q8w.vercel.app"
  JWT_EXPIRES: "7d"
  COOKIE_EXPIRE: "7"
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/configmap.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl get configmap -n medflow</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> ConfigMap = stockage de configuration non sensible. Ces valeurs seront inject√©es dans les pods comme variables d'environnement.
            </div>

            <h3>4.2 Cr√©er le Secret</h3>
            <p>Cr√©ez <code>k8s/secret.yaml</code>. Les valeurs doivent √™tre encod√©es en base64 :</p>
            
            <h4>Encodage des Secrets (PowerShell)</h4>
            <div class="command-box">
                <code>powershell -Command "[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes('dferetbvdfbrtyhyynuikd'))"</code>
            </div>
            <div class="command-box">
                <code>$mongoUri = "mongodb://admin:MedFlow2024Secure!@mongodb-service:27017/MeFlow2?authSource=admin" ; [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($mongoUri))</code>
            </div>
            <div class="command-box">
                <code>$password = "MedFlow2024Secure!" ; [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($password))</code>
            </div>

            <p>Exemple de <code>k8s/secret.yaml</code> :</p>
            <div class="code-block">
apiVersion: v1
kind: Secret
metadata:
  name: medflow-secrets
  namespace: medflow
type: Opaque
data:
  jwt-secret-key: ZGZlcmV0YnZkZmJydHloeXludWlrZA==
  mongo-uri: bW9uZ29kYjovL2FkbWluOk1lZEZsb3cyMDI0U2VjdXJlIUBtb25nb2RiLXNlcnZpY2U6MjcwMTcvTWVGbG93Mj9hdXRoU291cmNlPWFkbWlu
  mongo-password: TWVkRmxvdzIwMjRTZWN1cmUh
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/secret.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl get secret -n medflow</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Secret = stockage de donn√©es sensibles (mots de passe, cl√©s API, tokens). Les valeurs sont encod√©es en base64. Type Opaque = secret g√©n√©rique.
            </div>
        </div>

        <!-- ETAPE 5 -->
        <div id="etape5" class="section">
            <h2><span class="step-number">8</span>Deployments et Services</h2>
            
            <h3>5.1 Backend Deployment</h3>
            <p>Cr√©ez <code>k8s/backend-deployment.yaml</code> :</p>
            <div class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
  namespace: medflow
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: medflow-backend:latest
        ports:
        - containerPort: 4000
        envFrom:
        - configMapRef:
            name: medflow-config
        env:
        - name: JWT_SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: jwt-secret-key
        - name: MONGO_URI
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: mongo-uri
        livenessProbe:
          httpGet:
            path: /api/v1/health
            port: 4000
          initialDelaySeconds: 40
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/v1/health
            port: 4000
          initialDelaySeconds: 10
          periodSeconds: 5
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/backend-deployment.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=backend</code>
            </div>

            <h3>5.2 Backend Service</h3>
            <p>Cr√©ez <code>k8s/backend-service.yaml</code> :</p>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: medflow
spec:
  type: ClusterIP
  selector:
    app: backend
  ports:
  - port: 80
    targetPort: 4000
    protocol: TCP
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/backend-service.yaml</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Service ClusterIP expose les pods backend √† l'int√©rieur du cluster. Port 80 du service ‚Üí Port 4000 des pods.
            </div>

            <h3>5.3 Frontend et Dashboard</h3>
            <p>Cr√©ez les deployments et services pour frontend et dashboard (m√™me principe) :</p>
            <div class="command-box">
                <code>kubectl apply -f k8s/frontend-deployment.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/frontend-service.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/dashboard-deployment.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/dashboard-service.yaml</code>
            </div>

            <h3>5.4 V√©rification Compl√®te</h3>
            <div class="command-box">
                <code>kubectl get all -n medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl get services -n medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl get deployments -n medflow</code>
            </div>

            <h3>5.5 V√©rifier les Logs</h3>
            <div class="command-box">
                <code>kubectl logs -l app=backend -n medflow --tail=5</code>
            </div>
            <div class="command-box">
                <code>kubectl logs -l app=frontend -n medflow --tail=5</code>
            </div>
        </div>

        <!-- ETAPE 6 -->
        <div id="etape6" class="section">
            <h2><span class="step-number">9</span>MongoDB - Base de Donn√©es</h2>
            
            <h3>6.1 Cr√©er le PersistentVolumeClaim</h3>
            <p>Cr√©ez <code>k8s/mongodb-pvc.yaml</code> :</p>
            <div class="code-block">
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pvc
  namespace: medflow
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: standard
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/mongodb-pvc.yaml</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> PVC = demande de stockage persistant. 10Gi = 10 Go pour les donn√©es MongoDB. ReadWriteOnce = un seul pod peut √©crire.
            </div>

            <h3>6.2 Cr√©er le StatefulSet MongoDB</h3>
            <p>Cr√©ez <code>k8s/mongodb-statefulset.yaml</code> :</p>
            <div class="code-block">
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongodb
  namespace: medflow
spec:
  serviceName: mongodb-service
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:7
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          value: "admin"
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: medflow-secrets
              key: mongo-password
        ports:
        - containerPort: 27017
        volumeMounts:
        - name: mongodb-storage
          mountPath: /data/db
  volumeClaimTemplates:
  - metadata:
      name: mongodb-storage
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: standard
      resources:
        requests:
          storage: 10Gi
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/mongodb-statefulset.yaml</code>
            </div>

            <h3>6.3 Cr√©er le Service MongoDB</h3>
            <p>Cr√©ez <code>k8s/mongodb-service.yaml</code> :</p>
            <div class="code-block">
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service
  namespace: medflow
spec:
  clusterIP: None
  selector:
    app: mongodb
  ports:
  - port: 27017
    targetPort: 27017
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/mongodb-service.yaml</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Service headless (clusterIP: None) pour MongoDB. Permet la d√©couverte DNS des pods MongoDB.
            </div>

            <h3>6.4 V√©rifier MongoDB</h3>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=mongodb</code>
            </div>
            <div class="command-box">
                <code>kubectl logs -n medflow mongodb-0</code>
            </div>
        </div>

        <!-- ETAPE 7 -->
        <div id="etape7" class="section">
            <h2><span class="step-number">10</span>Ingress et Acc√®s Externe</h2>
            
            <h3>7.1 Activer l'Addon Ingress</h3>
            <div class="command-box">
                <code>minikube addons enable ingress</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n ingress-nginx</code>
            </div>

            <h3>7.2 Cr√©er l'Ingress</h3>
            <p>Cr√©ez <code>k8s/ingress.yaml</code> :</p>
            <div class="code-block">
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: medflow-ingress
  namespace: medflow
spec:
  ingressClassName: nginx
  rules:
  - host: api.medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: backend-service
            port:
              number: 80
  - host: dashboard.medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: dashboard-service
            port:
              number: 80
  - host: medflow.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/ingress.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl get ingress -n medflow</code>
            </div>

            <h3>7.3 D√©marrer Minikube Tunnel</h3>
            <div class="command-box">
                <code>minikube tunnel</code>
            </div>
            <div class="warning">
                <strong>‚ö†Ô∏è Important :</strong> Laissez ce terminal ouvert. Le tunnel doit rester actif pour que l'Ingress fonctionne.
            </div>

            <h3>7.4 Configurer le Fichier Hosts</h3>
            <p>Ajoutez dans <code>C:\Windows\System32\drivers\etc\hosts</code> :</p>
            <div class="code-block">
127.0.0.1 medflow.local
127.0.0.1 api.medflow.local
127.0.0.1 dashboard.medflow.local
127.0.0.1 grafana.medflow.local
127.0.0.1 prometheus.medflow.local
127.0.0.1 mongo.medflow.local
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Le fichier hosts permet de r√©soudre les noms de domaine localement sans serveur DNS.
            </div>

            <h3>7.5 V√©rifier l'Acc√®s</h3>
            <div class="command-box">
                <code>curl http://api.medflow.local/api/v1/health</code>
            </div>
            <div class="success">
                <strong>URLs d'acc√®s :</strong>
                <ul>
                    <li>Frontend : http://medflow.local</li>
                    <li>Dashboard : http://dashboard.medflow.local</li>
                    <li>API : http://api.medflow.local/api/v1</li>
                </ul>
            </div>
        </div>

        <!-- ETAPE 8 -->
        <div id="etape8" class="section">
            <h2><span class="step-number">11</span>HPA - Auto-scaling</h2>
            
            <h3>8.1 Activer Metrics-Server</h3>
            <div class="command-box">
                <code>minikube addons enable metrics-server</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n kube-system | findstr metrics-server</code>
            </div>

            <h3>8.2 Cr√©er l'HPA pour Backend</h3>
            <p>Cr√©ez <code>k8s/backend-hpa.yaml</code> :</p>
            <div class="code-block">
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-hpa
  namespace: medflow
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/backend-hpa.yaml</code>
            </div>

            <h3>8.3 Cr√©er l'HPA pour Frontend</h3>
            <div class="command-box">
                <code>kubectl apply -f k8s/frontend-hpa.yaml</code>
            </div>

            <h3>8.4 V√©rifier l'HPA</h3>
            <div class="command-box">
                <code>kubectl get hpa -n medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl get hpa -n medflow -o wide</code>
            </div>
            <div class="command-box">
                <code>kubectl top nodes</code>
            </div>
            <div class="command-box">
                <code>kubectl top pods -n medflow</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> HPA ajuste automatiquement le nombre de pods selon l'utilisation CPU et m√©moire. Si CPU > 70% ou Memory > 80%, l'HPA augmente le nombre de pods.
            </div>
        </div>

        <!-- ETAPE 9 -->
        <div id="etape9" class="section">
            <h2><span class="step-number">12</span>Monitoring - Prometheus & Grafana</h2>
            
            <h3>9.1 Cr√©er le Namespace Monitoring</h3>
            <div class="command-box">
                <code>kubectl create namespace monitoring</code>
            </div>

            <h3>9.2 D√©ployer Prometheus</h3>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/prometheus-rbac.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/prometheus-configmap.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/prometheus-deployment.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/prometheus-service.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/prometheus-ingress.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n monitoring</code>
            </div>

            <h3>9.3 D√©ployer Grafana</h3>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/grafana-configmap.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/grafana-deployment.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/grafana-service.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/monitoring/grafana-ingress.yaml</code>
            </div>

            <h3>9.4 Acc√®s au Monitoring</h3>
            <div class="success">
                <ul>
                    <li><strong>Prometheus :</strong> http://prometheus.medflow.local</li>
                    <li><strong>Grafana :</strong> http://grafana.medflow.local (admin/admin123)</li>
                </ul>
            </div>

            <h3>9.5 Requ√™tes PromQL Essentielles</h3>
            <div class="info-box">
                <strong>CPU des pods backend :</strong><br>
                <code>rate(container_cpu_usage_seconds_total{namespace="medflow", pod=~"backend.*"}[5m])</code>
            </div>
            <div class="info-box">
                <strong>M√©moire des pods backend :</strong><br>
                <code>container_memory_working_set_bytes{namespace="medflow", pod=~"backend.*"}</code>
            </div>
            <div class="info-box">
                <strong>Uptime du backend :</strong><br>
                <code>medflow_uptime_seconds{job="medflow-backend"}</code>
            </div>
            <div class="info-box">
                <strong>Nombre de pods backend :</strong><br>
                <code>count(medflow_uptime_seconds{job="medflow-backend"})</code>
            </div>
        </div>

        <!-- ETAPE 10 -->
        <div id="etape10" class="section">
            <h2><span class="step-number">13</span>CI/CD Pipeline - GitHub Actions</h2>
            
            <h3>10.1 Structure du Pipeline</h3>
            <p>Le pipeline se trouve dans <code>.github/workflows/ci-cd.yml</code></p>
            <div class="explanation">
                <strong>√âtapes du pipeline :</strong>
                <ol>
                    <li>Tests et Validation</li>
                    <li>Build des Images Docker</li>
                    <li>Push vers GitHub Container Registry</li>
                    <li>D√©ploiement sur Kubernetes (optionnel)</li>
                    <li>Health Checks</li>
                </ol>
            </div>

            <h3>10.2 Configuration des Permissions</h3>
            <p>Dans le workflow, ajoutez :</p>
            <div class="code-block">
permissions:
  contents: read
  packages: write
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Ces permissions permettent au workflow de cr√©er des packages dans GitHub Container Registry.
            </div>

            <h3>10.3 V√©rifier le Pipeline</h3>
            <div class="command-box">
                <code># Allez sur GitHub > Actions > CI/CD Pipeline - MedFlow</code>
            </div>
            <div class="success">
                <strong>R√©sultat attendu :</strong> Les images sont publi√©es dans "Packages" du repository GitHub.
            </div>
        </div>

        <!-- COMMANDES -->
        <div id="commandes" class="section">
            <h2>14. Commandes de V√©rification</h2>
            
            <h3>13.1 Commandes G√©n√©rales</h3>
            <table>
                <tr>
                    <th>Commande</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><code>minikube start</code></td>
                    <td>D√©marrer Minikube</td>
                </tr>
                <tr>
                    <td><code>kubectl get namespaces</code></td>
                    <td>Lister tous les namespaces</td>
                </tr>
                <tr>
                    <td><code>kubectl get all -n medflow</code></td>
                    <td>Voir toutes les ressources dans medflow</td>
                </tr>
                <tr>
                    <td><code>kubectl get pods -n medflow</code></td>
                    <td>Lister tous les pods</td>
                </tr>
                <tr>
                    <td><code>kubectl get services -n medflow</code></td>
                    <td>Lister tous les services</td>
                </tr>
                <tr>
                    <td><code>kubectl get deployments -n medflow</code></td>
                    <td>Lister tous les deployments</td>
                </tr>
                <tr>
                    <td><code>kubectl get ingress -n medflow</code></td>
                    <td>Lister les ingress</td>
                </tr>
                <tr>
                    <td><code>kubectl get hpa -n medflow</code></td>
                    <td>Voir les HPA</td>
                </tr>
            </table>

            <h3>13.2 Commandes par Composant</h3>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=backend</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=frontend</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=dashboard</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=mongodb</code>
            </div>

            <h3>13.3 Commandes de Logs</h3>
            <div class="command-box">
                <code>kubectl logs -l app=backend -n medflow --tail=50</code>
            </div>
            <div class="command-box">
                <code>kubectl logs -n medflow mongodb-0</code>
            </div>
            <div class="command-box">
                <code>kubectl logs -n medflow -l app=backend -f</code>
            </div>

            <h3>13.4 Commandes de Test</h3>
            <div class="command-box">
                <code>kubectl exec -it deployment/backend-deployment -n medflow -- wget -q -O- http://localhost:4000/api/v1/health</code>
            </div>
            <div class="command-box">
                <code>kubectl run test-pod --image=curlimages/curl --rm -it --restart=Never -n medflow -- curl -s http://backend-service/api/v1/health</code>
            </div>

            <h3>13.5 Test de R√©plication (Auto-healing)</h3>
            
            <h4>Commandes pour tester les replicas (auto-healing)</h4>
            <table>
                <tr>
                    <th>√âtape</th>
                    <th>Commande</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td><code>kubectl get pods -n medflow -l app=backend</code></td>
                    <td>Lister les pods backend avant suppression</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><code>kubectl delete pod &lt;pod-name&gt; -n medflow</code></td>
                    <td>Supprimer un pod (remplacez &lt;pod-name&gt; par le nom r√©el)</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td><code>kubectl get pods -n medflow -l app=backend -w</code></td>
                    <td>Observer en temps r√©el la recr√©ation (dans un autre terminal)</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td><code>kubectl get events -n medflow --sort-by='.lastTimestamp' | findstr backend</code></td>
                    <td>V√©rifier les √©v√©nements de cr√©ation/suppression</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td><code>kubectl describe deployment backend-deployment -n medflow | findstr -i "replicas desired current"</code></td>
                    <td>V√©rifier l'√©tat du deployment (replicas d√©sir√©s vs actuels)</td>
                </tr>
            </table>

            <h4>Commandes pour v√©rifier les replicas</h4>
            <table>
                <tr>
                    <th>Commande</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><code>kubectl get deployment backend-deployment -n medflow -o jsonpath='{.spec.replicas}'</code></td>
                    <td>Voir les replicas configur√©s (d√©sir√©s)</td>
                </tr>
                <tr>
                    <td><code>kubectl get deployment backend-deployment -n medflow -o jsonpath='{.status.replicas}'</code></td>
                    <td>Voir les replicas actuels (en cours d'ex√©cution)</td>
                </tr>
                <tr>
                    <td><code>kubectl get deployment backend-deployment -n medflow -o jsonpath='{.status.readyReplicas}'</code></td>
                    <td>Voir les replicas pr√™ts (READY)</td>
                </tr>
            </table>

            <div class="info-box" style="margin-top: 15px;">
                <strong>üí° Exemple pratique :</strong><br>
                <code>kubectl delete pod backend-deployment-867cdfdcff-f78cw -n medflow</code><br>
                Puis observez avec : <code>kubectl get pods -n medflow -l app=backend -w</code>
            </div>
            
            <div class="explanation">
                <strong>Explication :</strong> Apr√®s suppression d'un pod, Kubernetes d√©tecte automatiquement qu'il manque un pod et en cr√©e un nouveau pour maintenir le nombre de replicas configur√©. C'est le m√©canisme d'auto-healing (auto-gu√©rison).
            </div>

            <h3>13.6 Test de R√©partition de Charge</h3>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=backend -o wide</code>
            </div>
            <div class="command-box">
                <code>for /L %i in (1,1,10) do @kubectl run test-pod-%i --image=curlimages/curl --rm -it --restart=Never -n medflow -- curl -s http://backend-service/api/v1/health</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Le Service r√©partit les requ√™tes entre les diff√©rents pods backend.
            </div>

            <h3>13.7 Commandes de Monitoring</h3>
            <div class="command-box">
                <code>kubectl top nodes</code>
            </div>
            <div class="command-box">
                <code>kubectl top pods -n medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl get events -n medflow --sort-by='.lastTimestamp'</code>
            </div>
            <div class="command-box">
                <code>kubectl describe deployment backend-deployment -n medflow</code>
            </div>

            <h3>13.8 Test D√©taill√© du Dashboard et Frontend</h3>
            <div class="command-box">
                <code>kubectl run test-pod --image=curlimages/curl --rm -it --restart=Never -n medflow -- curl -s -o /dev/null -w "%{http_code}" http://dashboard-service/health</code>
            </div>
            <div class="command-box">
                <code>kubectl run test-pod --image=curlimages/curl --rm -it --restart=Never -n medflow -- curl -s -o /dev/null -w "%{http_code}" http://frontend-service/health</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Ces commandes testent les endpoints de sant√© du dashboard et du frontend. Le code de retour devrait √™tre 200.
            </div>

            <h3>13.9 Test D√©taill√© de R√©plication (Auto-healing)</h3>
            <h4>√âtape 1 : Lister les pods backend</h4>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=backend</code>
            </div>
            
            <h4>√âtape 2 : Supprimer un pod</h4>
            <div class="command-box">
                <code>kubectl delete pod backend-deployment-658f56c7f9-9cc79 -n medflow</code>
            </div>
            
            <h4>√âtape 3 : Observer la recr√©ation automatique</h4>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=backend -w</code>
            </div>
            <div class="command-box">
                <code>kubectl get events -n medflow --sort-by='.lastTimestamp' | findstr backend</code>
            </div>
            <div class="command-box">
                <code>kubectl describe deployment backend-deployment -n medflow | findstr -i "replicas desired current"</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Kubernetes d√©tecte automatiquement la suppression du pod et en cr√©e un nouveau pour maintenir le nombre de replicas d√©sir√© (3 pour backend).
            </div>

            <h3>13.10 Test de R√©partition de Charge D√©taill√©</h3>
            <h4>Voir la distribution des pods</h4>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=backend -o wide</code>
            </div>
            
            <h4>Envoyer plusieurs requ√™tes</h4>
            <div class="command-box">
                <code>for /L %i in (1,1,5) do @kubectl run test-pod-%i --image=curlimages/curl --rm -it --restart=Never -n medflow -- curl -s http://backend-service/api/v1/health >nul 2>&1 && echo Requete %i envoyee</code>
            </div>
            
            <h4>Test individuel</h4>
            <div class="command-box">
                <code>kubectl run test-pod-1 --image=curlimages/curl --rm -it --restart=Never -n medflow -- curl -s http://backend-service/api/v1/health</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Le Service Kubernetes r√©partit automatiquement les requ√™tes entre les diff√©rents pods backend. Chaque requ√™te peut √™tre trait√©e par un pod diff√©rent.
            </div>
        </div>

        <!-- MONGODB EXPRESS -->
        <div id="mongoexpress" class="section">
            <h2>15. MongoDB Express - Interface de Gestion</h2>
            
            <h3>15.1 D√©ployer MongoDB Express</h3>
            <div class="command-box">
                <code>kubectl apply -f k8s/mongo-express-deployment.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl apply -f k8s/mongo-express-service.yaml</code>
            </div>
            <div class="command-box">
                <code>kubectl get pods -n medflow -l app=mongo-express</code>
            </div>

            <h3>15.2 Acc√©der √† MongoDB Express</h3>
            <div class="success">
                <strong>URL :</strong> http://mongo.medflow.local<br>
                <strong>Identifiants :</strong> admin / admin123
            </div>
            <div class="explanation">
                <strong>Explication :</strong> MongoDB Express fournit une interface web pour g√©rer la base de donn√©es MongoDB directement depuis le navigateur.
            </div>
        </div>

        <!-- SUPERADMIN -->
        <div id="superadmin" class="section">
            <h2>16. Cr√©ation du SuperAdmin</h2>
            
            <h3>16.1 Activer le Port-Forward pour MongoDB</h3>
            <div class="command-box">
                <code>kubectl port-forward -n medflow pod/mongodb-0 27017:27017</code>
            </div>
            <div class="warning">
                <strong>‚ö†Ô∏è Important :</strong> Laissez ce terminal ouvert. Le port-forward doit rester actif.
            </div>

            <h3>16.2 Cr√©er le SuperAdmin</h3>
            <div class="command-box">
                <code>cd "C:\Users\Imed Brahmi\Desktop\MedFlow\backend"</code>
            </div>
            <div class="command-box">
                <code>$env:MONGO_URI="mongodb://admin:MedFlow2024Secure!@localhost:27017/MeFlow2?authSource=admin"; node scripts/seedSuperAdmin.js</code>
            </div>
            <div class="success">
                <strong>R√©sultat attendu :</strong><br>
                ‚úÖ SuperAdmin created successfully!<br>
                üìß Email: superadmin@zeecare.com<br>
                üîë Password: SuperAdmin123
            </div>

            <h3>16.3 V√©rifier dans MongoDB Compass</h3>
            <div class="info-box">
                <strong>Connexion MongoDB Compass :</strong><br>
                <strong>URI :</strong> mongodb://admin:MedFlow2024Secure!@localhost:27017/MeFlow2?authSource=admin<br>
                <strong>Ou formulaire :</strong><br>
                - Host: localhost<br>
                - Port: 27017<br>
                - Username: admin<br>
                - Password: MedFlow2024Secure!<br>
                - Authentication Database: admin
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Le SuperAdmin est cr√©√© dans la collection "users" avec le r√¥le "SuperAdmin". Vous pouvez le v√©rifier dans MongoDB Compass.
            </div>
        </div>

        <!-- GESTION IMAGES DOCKER -->
        <div id="gestion-images" class="section">
            <h2>17. Gestion des Images Docker</h2>
            
            <h3>17.1 Images N√©cessaires pour MedFlow</h3>
            <div class="info-box">
                <strong>‚úÖ Images √† CONSERVER :</strong>
                <ul>
                    <li><code>medflow-backend:latest</code> - Backend de l'application</li>
                    <li><code>medflow-frontend:latest</code> - Frontend patient</li>
                    <li><code>medflow-dashboard:latest</code> - Dashboard admin</li>
                    <li><code>gcr.io/k8s-minikube/kicbase:v0.0.48</code> - Image Minikube (NE PAS SUPPRIMER)</li>
                    <li><code>mongo:7.0</code> - Base de donn√©es MongoDB (si utilis√©e)</li>
                </ul>
            </div>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Images √† NE PAS SUPPRIMER :</strong>
                <ul>
                    <li><code>gcr.io/k8s-minikube/kicbase</code> - Utilis√©e par Minikube pour le cluster</li>
                    <li>Toutes les images avec le pr√©fixe <code>medflow-</code> - N√©cessaires pour l'application</li>
                </ul>
            </div>

            <h3>17.2 Lister les Images Docker</h3>
            <div class="command-box">
                <code>docker images</code>
            </div>
            <div class="command-box">
                <code>docker images | findstr medflow</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Affiche toutes les images Docker disponibles. La deuxi√®me commande filtre uniquement les images MedFlow.
            </div>

            <h3>17.3 Supprimer une Image Sp√©cifique</h3>
            <div class="command-box">
                <code>docker rmi &lt;image-id&gt;</code>
            </div>
            <div class="command-box">
                <code>docker rmi &lt;nom-image&gt;:&lt;tag&gt;</code>
            </div>
            <div class="explanation">
                <strong>Exemple :</strong> Si vous avez une image <code>postgres:latest</code> qui n'est plus utilis√©e :
                <div class="command-box">
                    <code>docker rmi postgres:latest</code>
                </div>
            </div>

            <h3>17.4 Supprimer les Images Inutilis√©es (Dangling)</h3>
            <div class="command-box">
                <code>docker image prune</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Supprime toutes les images "dangling" (sans tag, non utilis√©es). C'est une m√©thode s√ªre pour nettoyer.
            </div>

            <h3>17.5 Supprimer Toutes les Images Non Utilis√©es</h3>
            <div class="warning">
                <strong>‚ö†Ô∏è ATTENTION :</strong> Cette commande supprime TOUTES les images non utilis√©es par des conteneurs. Utilisez avec pr√©caution !
            </div>
            <div class="command-box">
                <code>docker image prune -a</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Supprime toutes les images qui ne sont pas utilis√©es par au moins un conteneur. Les images MedFlow en cours d'utilisation ne seront pas supprim√©es.
            </div>

            <h3>17.6 V√©rifier les Images Utilis√©es par Kubernetes</h3>
            <div class="command-box">
                <code>kubectl get pods -n medflow -o jsonpath='{range .items[*]}{.spec.containers[*].image}{"\n"}{end}' | sort -u</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Affiche toutes les images Docker utilis√©es par les Pods Kubernetes dans le namespace medflow. Ne supprimez PAS ces images !
            </div>

            <h3>17.7 Nettoyage Complet (Images + Conteneurs + Volumes)</h3>
            <div class="warning">
                <strong>‚ö†Ô∏è TR√àS ATTENTION :</strong> Cette commande supprime TOUT (images, conteneurs arr√™t√©s, r√©seaux, volumes non utilis√©s). √Ä utiliser uniquement si vous voulez tout nettoyer.
            </div>
            <div class="command-box">
                <code>docker system prune -a --volumes</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Nettoyage complet du syst√®me Docker. Ne supprime PAS les conteneurs en cours d'ex√©cution ni les images utilis√©es.
            </div>

            <h3>17.8 Exemple de Nettoyage S√©curis√©</h3>
            <div class="success">
                <strong>‚úÖ Proc√©dure recommand√©e :</strong>
                <ol>
                    <li>V√©rifier les images utilis√©es : <code>docker images</code></li>
                    <li>V√©rifier les images Kubernetes : <code>kubectl get pods -n medflow -o jsonpath='{range .items[*]}{.spec.containers[*].image}{"\n"}{end}'</code></li>
                    <li>Supprimer uniquement les images non list√©es ci-dessus</li>
                    <li>Nettoyer les images dangling : <code>docker image prune</code></li>
                </ol>
            </div>

            <h3>17.9 Espace Disque Lib√©r√©</h3>
            <div class="command-box">
                <code>docker system df</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Affiche l'utilisation de l'espace disque par Docker (images, conteneurs, volumes, cache de build).
            </div>
        </div>

        <!-- RECONSTRUCTION IMAGES -->
        <div id="reconstruction" class="section">
            <h2>18. Reconstruction des Images</h2>
            
            <h3>18.1 Reconstruire les Images dans Minikube</h3>
            <p>Si vous devez reconstruire les images apr√®s modification du code :</p>
            <div class="command-box">
                <code>minikube image build -t medflow-backend:latest ./backend</code>
            </div>
            <div class="command-box">
                <code>minikube image build --build-arg VITE_API_BASE_URL=http://api.medflow.local/api/v1 -t medflow-frontend:latest ./frontend</code>
            </div>
            <div class="command-box">
                <code>minikube image build --build-arg VITE_API_BASE_URL=http://api.medflow.local/api/v1 -t medflow-dashboard:latest ./dashboard</code>
            </div>

            <h3>18.2 Red√©marrer les Deployments</h3>
            <div class="command-box">
                <code>kubectl rollout restart deployment/backend-deployment -n medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl rollout restart deployment/frontend-deployment -n medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl rollout restart deployment/dashboard-deployment -n medflow</code>
            </div>
            <div class="explanation">
                <strong>Explication :</strong> Apr√®s reconstruction des images, red√©marrez les deployments pour utiliser les nouvelles images.
            </div>
        </div>

        <!-- TROUBLESHOOTING -->
        <div id="troubleshooting" class="section">
            <h2>19. D√©pannage</h2>
            
            <h3>19.1 Pods en Erreur</h3>
            <div class="command-box">
                <code>kubectl describe pod &lt;pod-name&gt; -n medflow</code>
            </div>
            <div class="command-box">
                <code>kubectl logs &lt;pod-name&gt; -n medflow</code>
            </div>

            <h3>19.2 Probl√®me de Connexion MongoDB</h3>
            <div class="command-box">
                <code>kubectl exec -n medflow mongodb-0 -- mongosh -u admin -p MedFlow2024Secure! --authenticationDatabase admin --eval "db.adminCommand('ping')"</code>
            </div>

            <h3>19.3 Probl√®me d'Ingress</h3>
            <div class="command-box">
                <code>kubectl describe ingress medflow-ingress -n medflow</code>
            </div>
            <div class="warning">
                <strong>V√©rifier :</strong> Le tunnel Minikube doit √™tre actif (<code>minikube tunnel</code>)
            </div>

            <h3>19.4 HPA ne Fonctionne Pas</h3>
            <div class="command-box">
                <code>kubectl get pods -n kube-system | findstr metrics-server</code>
            </div>
            <div class="command-box">
                <code>minikube addons enable metrics-server</code>
            </div>
            <div class="command-box">
                <code>Write-Host "Attente du d√©marrage de metrics-server..." ; Start-Sleep -Seconds 15 ; kubectl get pods -n kube-system | Select-String -Pattern "metrics-server"</code>
            </div>

            <h3>19.5 V√©rifier les M√©triques HPA</h3>
            <div class="command-box">
                <code>kubectl get hpa -n medflow -o wide</code>
            </div>
            <div class="command-box">
                <code>kubectl top nodes 2>&1 | Select-Object -First 3</code>
            </div>
            <div class="explanation">
                <strong>R√©sultat attendu :</strong><br>
                - Backend HPA : CPU 1%/70%, Memory 17%/80% (sous les seuils)<br>
                - Frontend HPA : CPU 1%/70%, Memory 14%/80% (sous les seuils)<br>
                - Si CPU > 70% ou Memory > 80%, l'HPA augmente automatiquement le nombre de pods
            </div>
        </div>

        <!-- R√âSUM√â -->
        <div class="section">
            <h2>üìä R√©sum√© Final</h2>
            
            <h3>Infrastructure D√©ploy√©e</h3>
            <ul>
                <li>‚úÖ Backend : 3 pods (HPA 2-10)</li>
                <li>‚úÖ Frontend : 2 pods (HPA 2-8)</li>
                <li>‚úÖ Dashboard : 2 pods</li>
                <li>‚úÖ MongoDB : 1 pod (StatefulSet)</li>
                <li>‚úÖ Prometheus : 1 pod</li>
                <li>‚úÖ Grafana : 1 pod</li>
            </ul>

            <h3>Acc√®s</h3>
            <ul>
                <li>Frontend : http://medflow.local</li>
                <li>Dashboard : http://dashboard.medflow.local</li>
                <li>API : http://api.medflow.local/api/v1</li>
                <li>Grafana : http://grafana.medflow.local (admin/admin123)</li>
                <li>Prometheus : http://prometheus.medflow.local</li>
                <li>MongoDB Express : http://mongo.medflow.local (admin/admin123)</li>
            </ul>

            <h3>Identifiants SuperAdmin</h3>
            <ul>
                <li>Email : superadmin@zeecare.com</li>
                <li>Password : SuperAdmin123</li>
            </ul>

            <h3>CI/CD</h3>
            <ul>
                <li>‚úÖ Pipeline GitHub Actions op√©rationnel</li>
                <li>‚úÖ Images Docker publi√©es dans GitHub Container Registry</li>
                <li>‚úÖ Build et tests automatis√©s</li>
            </ul>
        </div>

        <!-- GLOSSAIRE -->
        <div id="glossaire" class="section">
            <h2>20. Glossaire - D√©finitions des Notions</h2>
            
            <div class="info-box">
                <strong>üìö Objectif :</strong> Cette section d√©finit bri√®vement tous les concepts et technologies utilis√©s dans ce projet.
            </div>

            <h3>üîß Concepts Kubernetes</h3>
            
            <h4>Pod</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Pod est la plus petite unit√© d√©ployable dans Kubernetes. Il contient un ou plusieurs conteneurs qui partagent les m√™mes ressources r√©seau et stockage. Les Pods sont √©ph√©m√®res et peuvent √™tre cr√©√©s, supprim√©s et recr√©√©s automatiquement.
            </div>

            <h4>Deployment</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Deployment g√®re un ensemble de Pods identiques (replicas). Il assure la mise √† jour progressive, le rollback en cas d'erreur, et la cr√©ation automatique de nouveaux Pods si l'un d'eux √©choue. C'est la ressource recommand√©e pour d√©ployer des applications stateless.
            </div>

            <h4>Service</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Service expose un ensemble de Pods comme un point d'acc√®s r√©seau stable. Il fournit une adresse IP et un nom DNS qui restent constants m√™me si les Pods changent. Types : ClusterIP (interne), NodePort (port sur le n≈ìud), LoadBalancer (externe).
            </div>

            <h4>StatefulSet</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un StatefulSet g√®re des Pods avec une identit√© stable et un stockage persistant. Contrairement au Deployment, les Pods ont des noms ordonn√©s et pr√©visibles. Utilis√© pour des applications stateful comme les bases de donn√©es (MongoDB, MySQL).
            </div>

            <h4>Namespace</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Namespace est un m√©canisme d'isolation logique dans Kubernetes. Il permet de s√©parer les ressources (Pods, Services, etc.) en groupes virtuels, comme des dossiers dans un syst√®me de fichiers. Exemples : "medflow", "monitoring", "kube-system".
            </div>

            <h4>ConfigMap</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un ConfigMap stocke des donn√©es de configuration non sensibles sous forme de paires cl√©-valeur. Il permet de d√©coupler la configuration de l'application du code, facilitant la gestion des environnements (dev, prod). Les valeurs sont inject√©es dans les Pods comme variables d'environnement.
            </div>

            <h4>Secret</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Secret stocke des donn√©es sensibles (mots de passe, cl√©s API, tokens) de mani√®re s√©curis√©e. Les valeurs sont encod√©es en base64 (pas chiffr√©es, mais une pratique Kubernetes). Les Secrets sont mont√©s dans les Pods comme volumes ou variables d'environnement.
            </div>

            <h4>PersistentVolumeClaim (PVC)</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un PVC est une demande de stockage persistant. Il permet aux Pods de r√©clamer du stockage sans conna√Ætre les d√©tails du syst√®me de stockage sous-jacent. Le PVC est li√© √† un PersistentVolume (PV) qui fournit le stockage r√©el.
            </div>

            <h4>Ingress</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Ingress expose les Services HTTP/HTTPS √† l'ext√©rieur du cluster. Il fournit le routage bas√© sur le nom d'h√¥te (host) et le chemin (path), le SSL/TLS, et l'√©quilibrage de charge. Un contr√¥leur Ingress (comme Nginx) est n√©cessaire pour le faire fonctionner.
            </div>

            <h4>Horizontal Pod Autoscaler (HPA)</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> L'HPA ajuste automatiquement le nombre de Pods dans un Deployment ou StatefulSet en fonction de l'utilisation des ressources (CPU, m√©moire) ou de m√©triques personnalis√©es. Il augmente les replicas en cas de charge √©lev√©e et les diminue quand la charge baisse.
            </div>

            <h4>ReplicaSet</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un ReplicaSet maintient un nombre stable de Pods r√©pliqu√©s. Il garantit qu'un nombre sp√©cifique de Pods identiques fonctionne √† tout moment. Les Deployments utilisent des ReplicaSets pour g√©rer les Pods.
            </div>

            <h4>ServiceAccount</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un ServiceAccount fournit une identit√© pour les Pods qui s'ex√©cutent dans le cluster. Il est utilis√© pour l'authentification et l'autorisation avec l'API Kubernetes. Chaque namespace a un ServiceAccount par d√©faut.
            </div>

            <h4>RBAC (Role-Based Access Control)</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> RBAC est un m√©canisme de s√©curit√© qui contr√¥le l'acc√®s aux ressources Kubernetes. Il d√©finit des r√¥les (permissions) et les associe √† des utilisateurs ou ServiceAccounts via des RoleBindings ou ClusterRoleBindings.
            </div>

            <h3>üê≥ Concepts Docker</h3>
            
            <h4>Dockerfile</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Dockerfile est un fichier texte contenant des instructions pour construire une image Docker. Il d√©finit l'image de base, les d√©pendances, les fichiers √† copier, les commandes √† ex√©cuter, et les ports √† exposer.
            </div>

            <h4>Image Docker</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Une image Docker est un package immuable contenant une application et toutes ses d√©pendances. Elle sert de mod√®le pour cr√©er des conteneurs. Les images sont stock√©es dans des registries (Docker Hub, GitHub Container Registry).
            </div>

            <h4>Conteneur</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un conteneur est une instance ex√©cutable d'une image Docker. Il isole l'application et ses d√©pendances du syst√®me h√¥te, garantissant la portabilit√© et la coh√©rence entre les environnements.
            </div>

            <h3>‚ò∏Ô∏è Outils Kubernetes</h3>
            
            <h4>Minikube</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Minikube est un outil qui cr√©e un cluster Kubernetes local √† un seul n≈ìud dans une machine virtuelle ou un conteneur Docker. Il est utilis√© pour le d√©veloppement, les tests et l'apprentissage de Kubernetes sans avoir besoin d'un cluster complet.
            </div>

            <h4>kubectl</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> kubectl est l'outil en ligne de commande officiel pour interagir avec un cluster Kubernetes. Il permet de cr√©er, modifier, supprimer et inspecter les ressources Kubernetes (Pods, Services, Deployments, etc.).
            </div>

            <h4>Metrics-Server</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Metrics-Server collecte les m√©triques de ressources (CPU, m√©moire) des n≈ìuds et des Pods dans le cluster. Il est n√©cessaire pour que l'HPA fonctionne et pour utiliser la commande `kubectl top`.
            </div>

            <h3>üìä Monitoring</h3>
            
            <h4>Prometheus</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Prometheus est un syst√®me de monitoring et d'alerte open-source. Il collecte des m√©triques depuis les applications et les infrastructures, les stocke dans une base de donn√©es temporelle, et permet de cr√©er des alertes bas√©es sur des seuils.
            </div>

            <h4>Grafana</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Grafana est une plateforme de visualisation et d'analyse de donn√©es. Il se connecte √† Prometheus (et d'autres sources) pour cr√©er des tableaux de bord interactifs avec des graphiques, des alertes et des visualisations personnalis√©es.
            </div>

            <h4>PromQL</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> PromQL (Prometheus Query Language) est le langage de requ√™te de Prometheus. Il permet d'interroger et d'agr√©ger les m√©triques collect√©es pour cr√©er des graphiques, des alertes et des analyses.
            </div>

            <h4>Health Check</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Health Check (sonde de sant√©) est un m√©canisme qui v√©rifie p√©riodiquement l'√©tat d'un conteneur. Types : LivenessProbe (d√©tecte si le conteneur est vivant), ReadinessProbe (d√©tecte si le conteneur est pr√™t √† recevoir du trafic), StartupProbe (d√©tecte si le conteneur a d√©marr√©).
            </div>

            <h3>üîÑ CI/CD</h3>
            
            <h4>CI/CD (Continuous Integration / Continuous Deployment)</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> CI/CD est une pratique DevOps qui automatise l'int√©gration du code, les tests, la construction des images Docker, et le d√©ploiement. CI int√®gre le code fr√©quemment, CD d√©ploie automatiquement les changements valid√©s.
            </div>

            <h4>GitHub Actions</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> GitHub Actions est une plateforme d'automatisation int√©gr√©e √† GitHub. Elle permet de cr√©er des workflows (pipelines) qui s'ex√©cutent automatiquement lors d'√©v√©nements (push, pull request) pour tester, construire et d√©ployer des applications.
            </div>

            <h4>GitHub Container Registry</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> GitHub Container Registry (ghcr.io) est un registre Docker int√©gr√© √† GitHub. Il permet de stocker et partager des images Docker de mani√®re priv√©e ou publique, directement depuis les repositories GitHub.
            </div>

            <h3>üóÑÔ∏è Base de Donn√©es</h3>
            
            <h4>MongoDB</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> MongoDB est une base de donn√©es NoSQL orient√©e documents. Elle stocke les donn√©es sous forme de documents JSON (BSON), offrant flexibilit√© et scalabilit√© horizontale. Utilis√©e pour les applications n√©cessitant un sch√©ma flexible.
            </div>

            <h4>MongoDB Express</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> MongoDB Express (mongo-express) est une interface web pour g√©rer MongoDB. Il fournit une interface graphique pour visualiser, cr√©er, modifier et supprimer des bases de donn√©es, collections et documents.
            </div>

            <h4>MongoDB Compass</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> MongoDB Compass est l'interface graphique officielle de MongoDB. C'est une application desktop qui permet de visualiser et manipuler les donn√©es MongoDB, analyser les sch√©mas, et optimiser les performances.
            </div>

            <h3>üåê R√©seau</h3>
            
            <h4>ClusterIP</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> ClusterIP est le type de Service par d√©faut dans Kubernetes. Il expose le Service sur une IP interne au cluster, accessible uniquement depuis les Pods du cluster. C'est le type le plus s√©curis√© pour les services internes.
            </div>

            <h4>NodePort</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> NodePort expose le Service sur un port statique de chaque n≈ìud du cluster. Accessible depuis l'ext√©rieur via `<NodeIP>:<NodePort>`. Utilis√© pour le d√©veloppement et les tests, moins s√©curis√© en production.
            </div>

            <h4>LoadBalancer</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> LoadBalancer expose le Service via un √©quilibreur de charge externe fourni par le cloud provider (AWS ELB, GCP Load Balancer, Azure Load Balancer). Cr√©e automatiquement un √©quilibreur de charge externe.
            </div>

            <h4>Headless Service</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Headless Service (clusterIP: None) ne fournit pas d'IP de cluster. Il retourne directement les IPs des Pods, permettant la d√©couverte DNS directe. Utilis√© pour les StatefulSets et les applications n√©cessitant une connexion directe aux Pods.
            </div>

            <h3>üì¶ Ressources et Limites</h3>
            
            <h4>Resource Requests</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Les Resource Requests d√©finissent la quantit√© minimale de CPU et de m√©moire garantie pour un conteneur. Kubernetes utilise ces valeurs pour planifier les Pods sur les n≈ìuds ayant suffisamment de ressources disponibles.
            </div>

            <h4>Resource Limits</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Les Resource Limits d√©finissent la quantit√© maximale de CPU et de m√©moire qu'un conteneur peut utiliser. Si un conteneur d√©passe ses limites, il peut √™tre arr√™t√© ou throttl√© (ralenti) par Kubernetes.
            </div>

            <h3>üîÑ Strat√©gies de D√©ploiement</h3>
            
            <h4>Rolling Update</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Rolling Update est une strat√©gie de d√©ploiement qui met √† jour les Pods progressivement, un par un ou par petits groupes. Elle garantit une disponibilit√© continue de l'application pendant la mise √† jour, sans interruption de service.
            </div>

            <h4>Rollback</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Un Rollback est le retour √† une version pr√©c√©dente d'un d√©ploiement en cas d'erreur. Kubernetes stocke l'historique des d√©ploiements, permettant de revenir rapidement √† une version stable avec `kubectl rollout undo`.
            </div>

            <h3>üîê S√©curit√©</h3>
            
            <h4>Base64 Encoding</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Base64 est un encodage (pas un chiffrement) qui convertit des donn√©es binaires en texte ASCII. Utilis√© dans les Secrets Kubernetes pour stocker des valeurs sensibles. Note : ce n'est pas s√©curis√©, juste une pratique Kubernetes.
            </div>

            <h4>JWT (JSON Web Token)</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> JWT est un standard pour transmettre des informations de mani√®re s√©curis√©e entre parties. Il contient des claims (revendications) sign√©s num√©riquement, utilis√© pour l'authentification et l'autorisation dans les applications web.
            </div>

            <h3>üåç Acc√®s et Routage</h3>
            
            <h4>Port-Forward</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Port-Forward (`kubectl port-forward`) redirige un port local vers un port d'un Pod ou Service dans le cluster. Permet d'acc√©der temporairement √† un service depuis la machine locale, utile pour le d√©veloppement et le d√©bogage.
            </div>

            <h4>Minikube Tunnel</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Minikube Tunnel cr√©e une route r√©seau entre la machine h√¥te et le cluster Minikube. Il permet d'exposer les Services de type LoadBalancer et de faire fonctionner l'Ingress en local, en routant le trafic vers les Services Kubernetes.
            </div>

            <h4>Hosts File</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Le fichier hosts (`/etc/hosts` sur Linux/Mac, `C:\Windows\System32\drivers\etc\hosts` sur Windows) mappe des noms de domaine √† des adresses IP localement. Permet de r√©soudre des domaines personnalis√©s (comme `medflow.local`) sans serveur DNS.
            </div>

            <h3>üìà M√©triques et Performance</h3>
            
            <h4>Scaling Horizontal</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Le Scaling Horizontal (scale out) consiste √† augmenter le nombre d'instances (Pods) pour g√©rer plus de charge. Plus flexible et r√©silient que le scaling vertical (augmenter les ressources d'une instance).
            </div>

            <h4>Scaling Vertical</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Le Scaling Vertical (scale up) consiste √† augmenter les ressources (CPU, m√©moire) d'une instance existante. Moins flexible que le scaling horizontal, mais parfois n√©cessaire pour certaines applications.
            </div>

            <h4>Auto-healing</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> L'Auto-healing (auto-gu√©rison) est la capacit√© de Kubernetes √† d√©tecter automatiquement les Pods d√©faillants et √† les recr√©er. Assure la haute disponibilit√© en maintenant le nombre d√©sir√© de Pods fonctionnels.
            </div>

            <h4>Load Balancing</h4>
            <div class="explanation">
                <strong>D√©finition :</strong> Le Load Balancing (√©quilibrage de charge) distribue le trafic r√©seau entre plusieurs instances (Pods) d'une application. Les Services Kubernetes r√©partissent automatiquement les requ√™tes entre les Pods disponibles, am√©liorant les performances et la disponibilit√©.
            </div>

            <div class="success" style="margin-top: 30px;">
                <strong>‚úÖ Glossaire Complet</strong><br>
                Toutes les notions importantes du projet MedFlow sont d√©finies. Utilisez cette section comme r√©f√©rence rapide pour comprendre les concepts Kubernetes, Docker, et DevOps utilis√©s.
            </div>
        </div>

        <div style="text-align: center; margin-top: 50px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
            <p style="font-size: 1.2em; color: #667eea;"><strong>üéâ Projet MedFlow - D√©ploiement Kubernetes Complet</strong></p>
            <p style="margin-top: 10px;">Tous les composants sont op√©rationnels et document√©s</p>
        </div>
    </div>
</body>
</html>

